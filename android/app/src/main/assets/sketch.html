<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <!-- <script src="https://cdn.bootcss.com/vConsole/3.2.0/vconsole.min.js"></script> -->
  <title>canvas</title>
  <style>
    #imageFile,
    #downloadLink {
      display: none;
    }

    #operations {
      /* padding: 10px 0; */
      display: none;
    }

    html {
      -ms-content-zooming: none;
      -ms-touch-action: pan-x pan-y;
    }

    body {
      position: fixed;
      top: 0;
      right: 0;
      bottom: 0;
      left: 0;
      margin: 0;
      padding: 0;
      overflow: hidden;
    }

    * {
      user-select: none;
      -ms-user-select: none;
      -moz-user-select: none;
      -webkit-user-select: none;
    }
  </style>
</head>

<body>
  <div id="operations">
    <input type="button" id="pencil" value="铅笔" />
    <input type="button" id="straightLine" value="直线" />
    <input type="button" id="rectangle" value="矩形" />
    <input type="button" id="solidRectangle" value="实心矩形" />
    <input type="button" id="circle" value="圆形" />
    <input type="button" id="solidCircle" value="实心圆形" />
    <input type="button" id="arrow" value="箭头" />
    <input type="button" id="point" value="点" />
    <input type="button" id="text" value="文字" />
    <input type="button" id="eraser" value="橡皮擦" />
    <input type="button" id="image" value="导入图片" />
    <input type="button" id="save" value="保存" />
    <input type="button" id="redo" value="重做" />
    <input type="button" id="undo" value="撤销" />
    <input type="button" id="clear" value="清除" />
    <label>颜色：<input type="color" id="color" /></label>
    <label>线条粗细：1<input type="range" id="lineWidth" min="1" max="100" value="1" />100</label>
    <input type="file" id="imageFile" name="image" />
    <a id="downloadLink"></a>
  </div>
  <canvas id="canvas"></canvas>
  <script>
    // const vConsole = new VConsole();
    class Draw {
      constructor(elements) {
        const { canvas, color, lineWidth, operations, imageFile, downloadLink } = elements; // 控制画布的元素
        canvas.width = document.documentElement.clientWidth;
        canvas.height = document.documentElement.clientHeight;
        window.addEventListener('resize', function() {
          canvas.width = document.documentElement.clientWidth;
          canvas.height = document.documentElement.clientHeight;
        })
        this.type = 'pencil'; // 类型初始化为铅笔
        this.canvas = canvas; // canvas元素
        this.context = canvas.getContext('2d'); // 获取canvas的2d上下文对象
        this.canvasWidth = canvas.width; // 画布的宽度
        this.canvasHeight = canvas.height; // 画布的高度
        this.canvasBackground = '#ffffff'; // 画布的背景色
        this.isDrawing = false; // 是否在绘画中
        this.color = 'red'; // 处理颜色的DOM元素
        this.text = 'test'; // 处理文字的DOM元素
        this.lineWidth = 5; // 处理线宽的DOM元素
        this.pointInx = 1; // 点的索引
        this.img = '';
        this.fontSize = '12px Arial';
        this.operations = operations; // 包含所有操作的元素
        this.imageFile = imageFile; // 用于倒入图片的文件元素
        this.downloadLink = downloadLink; // 用于下载图片的元素
        this.image = new Image(); // 绘制形状时用到
        this.historyImage = new Image(); // 处理重做和撤销时用到
        this.historyUrls = []; // 存放每一步的base64 url（只取最新的十条）
        this.currentHistoryIndex = -1; // 当前历史记录的索引
      }

      init() {
        let originX = null, originY = null; // 同于存放每次鼠标点击（mousedown）时的坐标
        const { offsetLeft, offsetTop } = this.canvas;
        this.clear(); // 给画布一个白色的背景

        this.operations.addEventListener('click', (event) => {
          const handleClick = this.handleOperations();
          const handleCurrentClick = handleClick[event.target.id]; // 根据按下的操作按钮，选择不同的处理事件
          handleCurrentClick && handleCurrentClick();
        }, false);

        const handleDown = (event) => {
          this.isDrawing = true;
          this.image.src = this.canvas.toDataURL('image/png'); // 将当前图片转换为base64路径
          const { clientX, clientY } = this.getYX(event);
          originX = clientX - offsetLeft;
          originY = clientY - offsetTop;
          // 初始化context
          this.context.moveTo(originX, originY);
          this.context.lineWidth = this.lineWidth;
          this.context.strokeStyle = this.color;
          this.context.fillStyle = this.color;
          this.context.beginPath();
          if (this.type === "arrow") {
            this.x = event.clientX - this.canvas.getBoundingClientRect().left;
            this.y = event.clientY - this.canvas.getBoundingClientRect().top
          }
          if (this.type === "point") {
            this.handleMousemove().point({ x: originX, y: originY });
            this.isDrawing = false;
          }
        }

        const handleMove = (event) => {
          if (this.type === 'point') {
            return
          }
          if (this.isDrawing) {
            const { clientX, clientY } = this.getYX(event);
            const x = clientX - offsetLeft;
            const y = clientY - offsetTop;
            let newOriginX = originX, newOriginY = originY;
            let distanceX = Math.abs(x - originX);
            let distanceY = Math.abs(y - originY);

            // 让形状左上角的坐标永远大于右下角坐标，保证图形能正常绘制
            if (x < originX) newOriginX = x;
            if (y < originY) newOriginY = y;

            // (x, y)为鼠标移动的过程中在画布上的坐标，(originX, originY)为鼠标点击时在画布上的坐标，
            //（newOriginX, newOriginY）为绘制形状（比如矩形）时形状左上角的坐标
            const mousePosition = { x, y, originX, originY, newOriginX, newOriginY, distanceX, distanceY };
            if (this.type === 'arrow') {
              try {
                console.log('origin', originX, originY)
                this.handleMousemove().arrow(
                  this.context,
                  originX,
                  originY,
                  x,
                  y,
                  this.color
                )
              } catch (err) {
                console.log(err)
              }
            } else if (this.type === "text") {
              if (this.text !== null) {
                this.handleMousemove().text(mousePosition, this.text);
              }
            } else {
              let handleMousemove = this.handleMousemove();
              let currentHandleMousemove = handleMousemove[this.type]; // 根据当前类型的不同采取不同的操作
              currentHandleMousemove && currentHandleMousemove(mousePosition);
            }
          }
        }
        // this.canvas.addEventListener('mousedown', handleDown, false);
        // this.canvas.addEventListener('mouseleave', () => { this.endOfDrawing(); }, false);
        // this.canvas.addEventListener('mouseup', () => { this.endOfDrawing(); }, false);
        // this.canvas.addEventListener('mousemove', handleMove, false);
        this.canvas.addEventListener('touchstart', handleDown, false);
        this.canvas.addEventListener('touchmove', handleMove, false);
        this.canvas.addEventListener('touchend', () => { this.endOfDrawing(); }, false);
      }

      getYX(event) {
        let { clientX, clientY } = event;
        if ((!clientX || !clientY) && event?.changedTouches) {
          clientX = event?.changedTouches[0]?.clientX || 0;
          clientY = event?.changedTouches[0]?.clientY || 0;
        }
        return { clientX, clientY }
      }
      // 在绘制形状的过程中需要重新绘制，否则会画出移动过程中的图像
      reDraw() {
        this.context.clearRect(0, 0, this.canvasWidth, this.canvasHeight);
        this.context.drawImage(this.image, 0, 0);
        this.context.beginPath();
      }
      // 绘画结束
      endOfDrawing() {
        if (this.isDrawing) {
          this.text = null;
          this.context.closePath();
          this.isDrawing = false;
          window.ReactNativeWebView.postMessage(JSON.stringify({
            'type': 'onChange',
            'data': this.canvas.toDataURL('image/png')
          }));
        }
      }
      // 用背景色将画布填满
      clear() {
        this.context.fillStyle = this.canvasBackground;
        this.context.fillRect(0, 0, this.canvasWidth, this.canvasHeight);
        const image = new Image();
        image.onload = function () {
          try {
            const canvas = document.getElementById('canvas')
            const context = canvas.getContext('2d')
            context.drawImage(image, 0, 0, canvas.width, canvas.height);
          } catch (err) {
            alert(err)
          }
        };
        image.src = this.img;
      }
      // 添加历史记录
      addHistory() {
        (async () => {
          let dataUrl = this.canvas.toDataURL('image/png');
          this.historyUrls.push(dataUrl);
          let length = this.historyUrls.length;
          if (length > 10) {
            this.historyUrls = this.historyUrls.slice(-10, length);
          }
          this.currentHistoryIndex = this.historyUrls.length - 1;
        })()
      }
      // 点击操作按钮时触发的事件
      handleOperations() {
        return {
          pencil: () => { this.type = 'pencil'; }, // 铅笔按钮绑定的事件
          straightLine: () => { this.type = 'straightLine'; }, // 直线按钮绑定的事件
          rectangle: () => { this.type = 'rectangle'; }, // 矩形按钮绑定的事件
          solidRectangle: () => { this.type = 'solidRectangle'; }, // 实心矩形按钮绑定的事件
          eraser: () => { this.type = 'eraser'; }, // 橡皮擦绑定的事件
          circle: () => { this.type = 'circle'; }, // 圆形按钮绑定的事件
          point: () => { this.type = 'point'; }, // 点按钮绑定的事件
          arrow: () => { this.type = 'arrow'; }, // 圆形按钮绑定的事件
          solidCircle: () => { this.type = 'solidCircle'; }, // 实心圆形按钮绑定的事件
          text: () => {
            this.type = "text";
          },
          clear: () => { this.clear(); }, // 清除按钮绑定的事件
          image: () => { // 导入图片按钮绑定的事件
            this.imageFile.click();
            this.imageFile.onchange = (event) => {
              let reader = new FileReader();
              reader.readAsDataURL(event.target.files[0]);
              reader.onload = (evt) => {
                let img = new Image();
                img.src = evt.target.result;
                img.onload = () => {
                  this.context.drawImage(img, 0, 0); // 将图片画在画布上
                  // this.addHistory();
                };
              }
            }
          },
          save: () => { // 保存按钮绑定的事件
            this.downloadLink.href = this.canvas.toDataURL('image/png');
            this.downloadLink.download = 'drawing.png';
            this.downloadLink.click();
          },
          redo: () => { // 重做按钮绑定的事件
            let length = this.historyUrls.length;
            let currentIndex = this.currentHistoryIndex + 1;
            if (currentIndex > length - 1) {
              this.currentHistoryIndex = length - 1;
              return;
            };
            this.currentHistoryIndex = currentIndex;
            this.historyImage.src = this.historyUrls[currentIndex];
            this.historyImage.onload = () => {
              this.context.drawImage(this.historyImage, 0, 0);
            }
          },
          undo: () => { // 撤回按钮绑定的事件
            let currentIndex = this.currentHistoryIndex - 1;
            if (currentIndex < 0) {
              currentIndex === -1 && this.clear();
              this.currentHistoryIndex = -1;
              return;
            }
            this.currentHistoryIndex = currentIndex;
            this.historyImage.src = this.historyUrls[currentIndex];
            this.historyImage.onload = () => {
              this.context.drawImage(this.historyImage, 0, 0);
            }
          }
        }
      }
      setType(type) {
        this.type = type;
        window.ReactNativeWebView.postMessage(JSON.stringify({
          'type': 'setType',
          'data': type
        }));
      }
      setPointInx(pointInx) {
        this.pointInx = pointInx;
      }
      setText(text) {
        this.text = text;
      }
      setLineWidth(width) {
        this.lineWidth = width
      }
      setColor(color) {
        this.color = color
      }
      setFontSize(fontSize) {
        this.fontSize = `${fontSize} Arial`
      }
      setImg(img) {
        this.img = img;
        const image = new Image();
        image.src = img;
        image.onload = function () {
          try {
            const canvas = document.getElementById('canvas')
            const context = canvas.getContext('2d')
            context.clearRect(0, 0, canvas.width, canvas.height);
            context.drawImage(image, 0, 0, canvas.width, canvas.height);
          } catch (err) {
            console.info(err)
            alert(err)
          }
        };
      }
      save() {
        window.ReactNativeWebView.postMessage(JSON.stringify({
          'type': 'save',
          'data': this.canvas.toDataURL('image/png')
        }));
      }
      undo() {
        let currentIndex = this.currentHistoryIndex - 1;
        if (currentIndex < 0) {
          // currentIndex === -1 && this.clear();
          this.currentHistoryIndex = -1;
          return;
        }
        this.currentHistoryIndex = currentIndex;
        this.historyImage.src = this.historyUrls[currentIndex];
        this.historyImage.onload = () => {
          this.context.drawImage(this.historyImage, 0, 0);
        }
      }

      redo() {
        let length = this.historyUrls.length;
        let currentIndex = this.currentHistoryIndex + 1;
        if (currentIndex > length - 1) {
          this.currentHistoryIndex = length - 1;
          return;
        };
        this.currentHistoryIndex = currentIndex;
        this.historyImage.src = this.historyUrls[currentIndex];
        this.historyImage.onload = () => {
          this.context.drawImage(this.historyImage, 0, 0);
        }
      }

      // 不同类型的操作绑定在mousemove上的事件
      handleMousemove() {
        return {
          pencil: (mousePosition) => {
            const { x, y } = mousePosition;
            this.context.lineTo(x, y);
            this.context.stroke();
          },
          eraser: (mousePosition) => {
            const { x, y } = mousePosition;
            this.context.strokeStyle = this.canvasBackground;;
            this.context.lineTo(x, y);
            this.context.lineWidth = 30;
            this.context.stroke();
            this.context.strokeStyle = this.color.value;
            this.context.fillStyle = this.color.value;
          },
          straightLine: (mousePosition) => {
            let { x, y, originX, originY } = mousePosition;
            this.reDraw();
            this.context.moveTo(originX, originY);
            this.context.lineTo(x, y);
            this.context.stroke();
            this.context.closePath();
          },
          rectangle: (mousePosition) => {
            let { newOriginX, newOriginY, distanceX, distanceY } = mousePosition;
            this.reDraw();
            this.context.rect(newOriginX, newOriginY, distanceX, distanceY);
            this.context.stroke();

            this.context.closePath();
          },
          solidRectangle: (mousePosition) => {
            let { newOriginX, newOriginY, distanceX, distanceY } = mousePosition;
            this.reDraw();
            this.context.fillRect(newOriginX, newOriginY, distanceX, distanceY);
            this.context.closePath();
          },
          circle: (mousePosition) => {
            let { newOriginX, newOriginY, distanceX, distanceY } = mousePosition;
            this.reDraw();

            let r = Math.sqrt(distanceX * distanceX + distanceY * distanceY);
            this.context.arc(distanceX + newOriginX, distanceY + newOriginY, r, 0, 2 * Math.PI);
            this.context.stroke();

            this.context.closePath();
          },
          solidCircle: (mousePosition) => {
            let { newOriginX, newOriginY, distanceX, distanceY } = mousePosition;
            this.reDraw();

            let r = Math.sqrt(distanceX * distanceX + distanceY * distanceY);
            this.context.arc(distanceX + newOriginX, distanceX + newOriginY, r, 0, 2 * Math.PI);
            this.context.fillStyle = this.color.value;
            this.context.fill();

            this.context.closePath();
          },
          point: (mousePosition) => {
            let { x, y } = mousePosition;
            this.context.beginPath();
            this.context.lineWidth = 2;
            this.context.strokeStyle = this.color;
            this.context.arc(x, y - 2, 15, 0, Math.PI * 2, false);
            this.context.stroke();
            this.context.fillStyle = this.color;
            this.context.font = '16px Arial';
            this.context.textAlign = "center";
            this.context.textBaseline = "middle";
            this.context.fillText(this.pointInx, x, y);
            window.ReactNativeWebView.postMessage(JSON.stringify({
              'type': 'point',
              'data': this.pointInx
            }));
            this.context.closePath();
          },
          text: (mousePosition, text) => {
            let { x, y } = mousePosition;
            this.reDraw();
            this.context.beginPath();
            this.context.fillStyle = this.color;
            this.context.font = this.fontSize;
            this.context.textAlign = "center";
            this.context.textBaseline = "middle";
            this.context.fillText(text, x, y);
          },
          arrow: (ctx, pointerX, pointerY, pointerX1, pointerY1, color) => {
            this.reDraw();
            const theta = 30;
            const headlen = 12;
            const angle = (Math.atan2(pointerY - pointerY1, pointerX - pointerX1) * 180) / Math.PI;
            const angle1 = ((angle + theta) * Math.PI) / 180;
            const angle2 = ((angle - theta) * Math.PI) / 180;
            const topX = headlen * Math.cos(angle1);
            const topY = headlen * Math.sin(angle1);
            const bottomX = headlen * Math.cos(angle2);
            const bottomY = headlen * Math.sin(angle2);
            ctx.save();
            ctx.beginPath();
            let arrowX, arrowY;
            ctx.moveTo(pointerX, pointerY);
            ctx.lineTo(pointerX1, pointerY1);
            arrowX = pointerX1 + topX;
            arrowY = pointerY1 + topY;
            ctx.moveTo(arrowX, arrowY);
            ctx.lineTo(pointerX1, pointerY1);
            arrowX = pointerX1 + bottomX;
            arrowY = pointerY1 + bottomY;
            ctx.lineTo(arrowX, arrowY);
            ctx.strokeStyle = color;
            ctx.lineWidth = this.lineWidth;
            ctx.stroke();
            ctx.restore();
            ctx.closePath();
          },
          clear: () => {
            this.clear();
          }
        }
      }
    }
    // 获取页面中的元素
    try {
      const canvas = document.getElementById('canvas');
      const color = document.getElementById('color');
      const lineWidth = document.getElementById('lineWidth');
      const operations = document.getElementById('operations');
      const imageFile = document.getElementById('imageFile');
      const downloadLink = document.getElementById('downloadLink');

      const elements = {
        canvas,
        color,
        lineWidth,
        operations,
        imageFile,
        downloadLink
      };
      const draw = new Draw(elements);
      window.draw = draw;
      draw.init();
      // 接收app消息
      document.addEventListener('message', function (e) {
        const data = JSON.parse(e.data)
        switch (data.type) {
          case 'shape':
            draw.setType(data.param);
            return;
          case 'point':
            draw.setType('point');
            return;
          case 'setPointInx':
            draw.setPointInx(data.param);
            return;
          case 'text':
            draw.setText(data.param);
            draw.setType('text');
            return;
          case 'fontSize':
            draw.setFontSize(data.param);
            return;
          case 'clear':
            draw.clear();
            return
          case 'undo':
            draw.undo();
            return
          case 'lineWidth':
            draw.setLineWidth(data.param)
            return
          case 'color':
            draw.setColor(data.param)
            return
          case 'save':
            draw.save()
            return
          case 'img':
            draw.setImg(data.param)
            return
          default: window.ReactNativeWebView.postMessage('hi');
        }
      });
    } catch (err) {
      console.info(err)
    }

  </script>
</body>

</html>